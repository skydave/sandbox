#include "SurfaceClouds.h"
#include <stdio.h>
#include <cstdlib>
#include <string>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>


#include <util/StringManip.h>
#include <math/PerlinNoise.h>


SurfaceClouds::SurfaceClouds()
{
	m_geo = base::geo_grid( 250, 250 );
	base::apply_transform( m_geo, math::Matrix44f::ScaleMatrix( 30000.0f ) );

	/*
	// temp
	{
		math::PerlinNoise pn;
		pn.setDepth(2);
		pn.setFrequency(20.0);
		base::AttributePtr ps = m_geo->getAttr( "P" );
		base::AttributePtr uvs = m_geo->getAttr( "UV" );

		int numElements= uvs->numElements();
		for( int i=0;i<numElements;++i )
		{
			math::Vec3f p = ps->get<math::Vec3f>(i);
			math::Vec2f uv = uvs->get<math::Vec2f>(i);
			float n = pn.perlinNoise_2D(uv.x, uv.y)*0.5*0.5;
			p.y += n*6000.0;
			ps->set(i, p );
		}
	}
	*/


	base::apply_normals( m_geo );

	m_shader = base::Shader::load(base::Path( SRC_PATH ) + "/src/SurfaceClouds.vs.glsl", base::Path( SRC_PATH ) + "/src/SurfaceClouds.ps.glsl").attachPS( base::glsl::noiseSrc() ).attachVS( base::glsl::noiseSrc() );





	// get samples of Ptheta (generated by mieplot)
	std::vector<float> P_theta_samples;

    std::string STRING;
	std::ifstream infile;
	infile.open( base::Path( SRC_PATH ) + "/data/mieplot_results1_phasefun.txt" );

    while(!infile.eof()) // To get you all the lines.
    {
	    std::getline(infile,STRING); // Saves the line in STRING.
		{
			std::vector<std::string> parts;
			//split string at whitespaces
			base::splitString( STRING, parts );

			if( parts.size() == 4 )
			{
				float intensity = base::fromString<float>(parts[2]);
				P_theta_samples.push_back(intensity);
			}
		}
    }
	infile.close();




	m_parameters = base::Texture2d::createRGBAFloat32();

	base::FCurvePtr b;
	b = base::FCurvePtr( new base::FCurve() );
	b->addCP(1.0f - cos(math::degToRad(0.0f)), 1.1796f);
	b->addCP(1.0f - cos(math::degToRad(10.0f)), 1.1293f);
	b->addCP(1.0f - cos(math::degToRad(20.0f)), 1.1382f);
	b->addCP(1.0f - cos(math::degToRad(30.0f)), 1.0953f);
	b->addCP(1.0f - cos(math::degToRad(40.0f)), 0.9808f);
	b->addCP(1.0f - cos(math::degToRad(50.0f)), 0.9077f);
	b->addCP(1.0f - cos(math::degToRad(60.0f)), 0.7987f);
	b->addCP(1.0f - cos(math::degToRad(70.0f)), 0.6629f);
	b->addCP(1.0f - cos(math::degToRad(80.0f)), 0.5043f);
	b->addCP(1.0f - cos(math::degToRad(90.0f)), 0.3021f);
	base::FCurvePtr c;
	c = base::FCurvePtr( new base::FCurve() );
	c->addCP(1.0f - cos(math::degToRad(0.0f)), 0.0138f);
	c->addCP(1.0f - cos(math::degToRad(10.0f)), 0.0154f);
	c->addCP(1.0f - cos(math::degToRad(20.0f)), 0.0131f);
	c->addCP(1.0f - cos(math::degToRad(30.0f)), 0.0049f);
	c->addCP(1.0f - cos(math::degToRad(40.0f)), 0.0012f);
	c->addCP(1.0f - cos(math::degToRad(50.0f)), 0.0047f);
	c->addCP(1.0f - cos(math::degToRad(60.0f)), 0.0207f);
	c->addCP(1.0f - cos(math::degToRad(70.0f)), 0.0133f);
	c->addCP(1.0f - cos(math::degToRad(80.0f)), 0.0280f);
	c->addCP(1.0f - cos(math::degToRad(90.0f)), 0.0783f);
	base::FCurvePtr kc;
	kc = base::FCurvePtr( new base::FCurve() );
	kc->addCP(1.0f - cos(math::degToRad(0.0f)), 0.0265f);
	kc->addCP(1.0f - cos(math::degToRad(10.0f)), 0.0262f);
	kc->addCP(1.0f - cos(math::degToRad(20.0f)), 0.0272f);
	kc->addCP(1.0f - cos(math::degToRad(30.0f)), 0.0294f);
	kc->addCP(1.0f - cos(math::degToRad(40.0f)), 0.0326f);
	kc->addCP(1.0f - cos(math::degToRad(50.0f)), 0.0379f);
	kc->addCP(1.0f - cos(math::degToRad(60.0f)), 0.0471f);
	kc->addCP(1.0f - cos(math::degToRad(70.0f)), 0.0616f);
	kc->addCP(1.0f - cos(math::degToRad(80.0f)), 0.0700f);
	kc->addCP(1.0f - cos(math::degToRad(90.0f)), 0.0700f);
	base::FCurvePtr t;
	t = base::FCurvePtr( new base::FCurve() );
	t->addCP(1.0f - cos(math::degToRad(0.0f)), 0.8389f);
	t->addCP(1.0f - cos(math::degToRad(10.0f)), 0.8412f);
	t->addCP(1.0f - cos(math::degToRad(20.0f)), 0.8334f);
	t->addCP(1.0f - cos(math::degToRad(30.0f)), 0.8208f);
	t->addCP(1.0f - cos(math::degToRad(40.0f)), 0.8010f);
	t->addCP(1.0f - cos(math::degToRad(50.0f)), 0.7774f);
	t->addCP(1.0f - cos(math::degToRad(60.0f)), 0.7506f);
	t->addCP(1.0f - cos(math::degToRad(70.0f)), 0.7165f);
	t->addCP(1.0f - cos(math::degToRad(80.0f)), 0.7149f);
	t->addCP(1.0f - cos(math::degToRad(90.0f)), 0.1000f);
	base::FCurvePtr r;
	r = base::FCurvePtr( new base::FCurve() );
	r->addCP(1.0f - cos(math::degToRad(0.0f)), 0.0547f);
	r->addCP(1.0f - cos(math::degToRad(10.0f)), 0.0547f);
	r->addCP(1.0f - cos(math::degToRad(20.0f)), 0.0552f);
	r->addCP(1.0f - cos(math::degToRad(30.0f)), 0.0564f);
	r->addCP(1.0f - cos(math::degToRad(40.0f)), 0.0603f);
	r->addCP(1.0f - cos(math::degToRad(50.0f)), 0.0705f);
	r->addCP(1.0f - cos(math::degToRad(60.0f)), 0.0984f);
	r->addCP(1.0f - cos(math::degToRad(70.0f)), 0.1700f);
	r->addCP(1.0f - cos(math::degToRad(80.0f)), 0.3554f);
	r->addCP(1.0f - cos(math::degToRad(90.0f)), 0.9500f);
	m_phaseFunction = base::FCurve(base::FCurve::LINEAR);
	float theta = 0.0f;
	for(int n=0; n<P_theta_samples.size();++n)
	{
		m_phaseFunction.addCP(theta/MATH_PIf, P_theta_samples[n]);
		theta += (MATH_PIf/P_theta_samples.size());
	}

	// compute Pf
	{
		float theta_f = math::degToRad(5.0f); // in rad
		// integrate one slice
		float A_slice = 0.0f;

		float theta = 0.0f;
		int numS = 500;
		for(int n=0; n<numS;++n)
		{
			if( theta < theta_f )
				A_slice += m_phaseFunction.eval((float)n/(float)numS)*sin(theta);

			theta += (MATH_PIf/numS);
		}
		A_slice = (MATH_PIf/numS)*A_slice;
		float Pf = 2.0f * MATH_PIf * A_slice;

		// normalize over solid angle of sphere
		Pf /= 4.0f*MATH_PIf;

		std::cout << "Pf=" << Pf << std::endl;
		m_shader->setUniform( "P_f", Pf );
		m_shader->setUniform( "theta_f", theta_f );
	}

	int numSamples = 512;
	int numParameters = 2;
	m_parameters_tex = (float *)malloc(numSamples*numParameters*4*sizeof(float));
	for(int i =0; i<numSamples; ++i)
	{
		int row = numSamples*4;
		float one_minus_cos_theta = (float)i/(float)numSamples;
		float cos_theta = 1.0f - one_minus_cos_theta;
		m_parameters_tex[i*4] = b->eval(cos_theta);
		m_parameters_tex[i*4+1] = c->eval(cos_theta);
		m_parameters_tex[i*4+2] = kc->eval(cos_theta);
		m_parameters_tex[i*4+3] = t->eval(cos_theta);

		m_parameters_tex[row+i*4] = r->eval(cos_theta);
		m_parameters_tex[row+i*4+1] = m_phaseFunction.eval((float)i/(float)numSamples);
		//m_parameters_tex[row+i*4+1] = 0.1f;
		m_parameters_tex[row+i*4+2] = 0.0;
		m_parameters_tex[row+i*4+3] = 0.0;
	}
	m_parameters->uploadRGBAFloat32(numSamples, numParameters, m_parameters_tex);

	m_shader->setUniform( "parameters", m_parameters->getUniform() );

	m_shader->setUniform( "C_sun", math::Vec3f(1.0f, 1.0f, 1.0f) );

	m_shader->setUniform( "re", 0.000007f );
	m_shader->setUniform( "N0", 300000000.0f );




	// initial setup
	//setSunDir( math::Vec3f( 1.0f, 1.0f, 1.0f ) );
	setSunDir( math::Vec3f( 0.007838f, 0.224801f, -0.852747f ) );
	setMaxVertexHeight( 500.0f );
}


SurfaceClouds::~SurfaceClouds()
{
	free(m_parameters_tex);
}


void SurfaceClouds::setSunDir( math::Vec3f sunDir )
{
	m_shader->setUniform( "sunDir", sunDir.normalized() );
	m_sunDir = sunDir;
}

void SurfaceClouds::setMaxVertexHeight( float maxVertexHeight )
{
	m_shader->setUniform( "maxVertexHeight", maxVertexHeight );
	m_maxVertexHeight = maxVertexHeight;
}